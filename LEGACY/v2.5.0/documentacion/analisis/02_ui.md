# EVARISIS Gestor H.U.V — Análisis de Componente: ui.py
**Ruta (relativa)**: `ui.py`  
**Tipo**: codigo  
**Última revisión**: 15/09/2025  

## 1. Rol y responsabilidad única

Orquestador central de la interfaz CustomTkinter que coordina las 4 vistas principales (Procesar PDFs, Visualizar Datos, Dashboard Analítico, Automatizar BD Web) y gestiona el pipeline completo de procesamiento con threading no-bloqueante.

## 2. Resumen técnico (5–8 líneas)

La clase `App` implementa una interfaz moderna de escritorio que actúa como punto de control único para todo el flujo de procesamiento de informes IHQ. Integra el motor OCR, la extracción especializada, la persistencia SQLite y la visualización analítica en una experiencia cohesiva. Utiliza threading para operaciones de larga duración, mantiene estado consistente entre vistas y proporciona feedback en tiempo real al usuario. Es el componente con mayor complejidad del sistema al coordinar todos los demás módulos, desde OCR hasta dashboard analítico con Matplotlib/Seaborn.

## 3. Estructura interna y flujo

### Puntos clave

* **`App.__init__()`**: Inicialización de interfaz y configuración visual
  * **Entradas**: None
  * **Salidas**: Interfaz CustomTkinter configurada con 4 pestañas, tema oscuro

* **`create_processing_tab()`**: Vista "Procesar PDFs" con selección de archivos y log en vivo
  * **Entradas**: Widgets padre
  * **Salidas**: Frame con controles de selección, botones de acción y panel de log

* **`create_visualization_tab()`**: Vista "Visualizar Datos" con tabla maestro y panel de detalles
  * **Entradas**: Widgets padre  
  * **Salidas**: Frame con TreeView, buscador y panel lateral de metadatos

* **`create_dashboard_tab()`**: Vista "Dashboard Analítico" con visualizaciones Matplotlib
  * **Entradas**: Widgets padre
  * **Salidas**: Frame con filtros dinámicos y múltiples gráficos embebidos

* **`create_automation_tab()`**: Vista "Automatizar BD Web" con bot Selenium
  * **Entradas**: Widgets padre
  * **Salidas**: Frame con campos de credenciales y calendario de fechas

* **`process_files_thread()`**: Pipeline de procesamiento en hilo separado
  * **Entradas**: Lista de archivos PDF seleccionados
  * **Salidas**: Registros en SQLite, logs de progreso, actualización UI

* **`load_and_display_data()`**: Carga datos desde SQLite y actualiza tabla maestro
  * **Entradas**: None (lee directamente de base de datos)
  * **Salidas**: Actualización TreeView con registros filtrados

* **`update_dashboard()`**: Regenera gráficos del dashboard según filtros activos
  * **Entradas**: Filtros de fecha, servicio, malignidad, responsable
  * **Salidas**: Gráficos Matplotlib/Seaborn actualizados

### Flujo principal

1. **Inicialización**: Configuración CustomTkinter con tema oscuro y ventana maximizada
2. **Creación de pestañas**: 4 frames independientes con controles específicos
3. **Selección de archivos**: FileDialog para PDFs → lista de archivos pendientes
4. **Procesamiento threaded**: Lanzamiento de hilo para evitar bloqueo UI
5. **Pipeline OCR → Extracción**: Cada PDF pasa por `procesador_ihq_biomarcadores`
6. **Persistencia**: Registros normalizados guardados en SQLite vía `database_manager`
7. **Visualización**: Carga automática de datos en tabla maestro con búsqueda
8. **Dashboard analítico**: Filtros dinámicos regeneran gráficos en tiempo real
9. **Automatización opcional**: Bot Selenium para portal institucional

## 4. Entradas y salidas

| Tipo | Nombre/Ruta | Formato | Consumido por | Frecuencia |
|------|-------------|---------|---------------|------------|
| **Entrada** | PDFs seleccionados | FileDialog | `process_files_thread()` | Por sesión de procesamiento |
| **Entrada** | Registros SQLite | `huv_oncologia.db` | `load_and_display_data()` | Cada actualización de vista |
| **Entrada** | Filtros dashboard | Controles UI | `update_dashboard()` | Cada cambio de filtro |
| **Entrada** | Credenciales portal | Campos de texto | `huv_web_automation.py` | Por automatización web |
| **Salida** | Logs procesamiento | Panel de log | Usuario final | Tiempo real durante procesamiento |
| **Salida** | Tabla de datos | TreeView | Usuario final | Después de carga/filtrado |
| **Salida** | Gráficos dashboard | Canvas Matplotlib | Usuario final | Después de filtrado |
| **Salida** | Consulta portal | Navegador Chrome | Portal HUV | Por automatización web |

## 5. Dependencias e interacciones

### Internas
- **→ `procesador_ihq_biomarcadores`**: Pipeline principal de extracción de datos
- **→ `database_manager`**: Operaciones CRUD SQLite (save_records, get_all_records_as_dataframe)
- **→ `huv_web_automation`**: Automatización del portal institucional
- **→ `calendario.CalendarioInteligente`**: Widget de selección de fechas con festivos
- **← `huv_ocr_sistema_definitivo.py`**: Punto de entrada que instancia App

### Externas
- **`customtkinter`**: Framework UI moderno con temas y widgets avanzados
- **`matplotlib/seaborn`**: Visualizaciones del dashboard analítico
- **`pandas`**: Manipulación de DataFrames para filtrado y análisis
- **`tkinter.ttk`**: TreeView para tabla maestro de registros
- **`threading`**: Procesamiento no-bloqueante de archivos
- **`datetime`**: Manejo de fechas para filtros temporales

### Contrato con EVARISIS Dashboard
- **Instanciación**: `App()` desde punto de entrada principal
- **Estado UI**: Mantiene estado persistente entre sesiones mediante SQLite
- **Transferencia de control**: `mainloop()` bloquea hasta cierre de aplicación

## 6. Errores, excepciones y resiliencia

### Categorías de error
- **Archivos PDF corruptos**: OCR falla o extracción devuelve datos incompletos
- **Base de datos bloqueada**: SQLite concurrencia durante escritura/lectura
- **Memoria insuficiente**: Procesamiento de lotes muy grandes de PDFs
- **Selenium failures**: Portal web cambia estructura o credenciales inválidas
- **Matplotlib rendering**: Gráficos complejos con datasets grandes

### Estrategias de manejo
- **Threading con try-catch**: Errores en procesamiento no bloquean UI
- **Logging detallado**: Panel de log muestra progreso y errores en tiempo real
- **Graceful degradation**: Dashboard muestra datos disponibles aunque algunos gráficos fallen
- **User feedback**: Mensajes informativos sobre estado de operaciones
- **Rollback implícito**: SQLite transaccional evita corrupción en fallos

## 7. Seguridad y datos sensibles

### Datos sensibles
- **Credenciales portal**: Usuario/contraseña almacenados temporalmente en memoria
- **Información médica**: Datos de pacientes mostrados en tabla y gráficos
- **Rutas de archivos**: PDFs procesados pueden contener información sensible de rutas

### Buenas prácticas presentes
- **No persistencia de credenciales**: Login portal no se guarda en disco
- **Threading aislado**: Procesamiento en hilos separados evita bloqueos críticos
- **Validación de entrada**: Filtros de archivos PDF únicamente

### Deudas de seguridad
- **Sin cifrado de base datos**: SQLite almacena datos médicos sin cifrar
- **Logs potencialmente verbosos**: Información de pacientes en logs de debug
- **Sin autenticación**: No hay control de acceso a la aplicación
- **Credenciales en memoria**: Potencial exposición si hay volcado de memoria

## 8. Rendimiento y complejidad

### Operaciones costosas
- **Procesamiento masivo de PDFs**: OCR + extracción por archivo (threading mitiga)
- **Renderizado de gráficos**: Matplotlib con datasets grandes (> 1000 registros)
- **Actualización TreeView**: Refrescar tabla con muchos registros causa lag
- **Queries SQLite complejas**: Filtros complejos en dashboard pueden ser lentos

### Complejidad
- **Temporal**: O(n) por procesamiento de archivos, O(n log n) para ordenamiento TreeView
- **Espacial**: O(n) para almacenamiento DataFrame maestro en memoria

### Oportunidades de optimización
- **Paginación TreeView**: Cargar registros por lotes en lugar de tabla completa
- **Cache de gráficos**: Evitar regeneración si filtros no cambian significativamente
- **Lazy loading**: Cargar detalles de registro solo cuando se selecciona
- **Pool de threads**: Reutilizar hilos en lugar de crear uno por procesamiento
- **Índices SQLite**: Optimizar queries de filtrado con índices apropiados

## 9. Puntos de extensión y mantenibilidad

### Extensiones sin romper contratos
- **Nuevas pestañas**: Framework de pestañas permite agregar vistas adicionales
- **Filtros adicionales**: Dashboard acepta nuevos criterios de filtrado
- **Exportaciones**: Botones de exportación pueden añadirse a cualquier vista
- **Temas adicionales**: CustomTkinter soporta temas personalizados
- **Gráficos adicionales**: Framework Matplotlib permite nuevas visualizaciones

### Acoplamientos a reducir
- **Dependencia directa procesadores**: Podría abstraerse vía interface común
- **Lógica de negocio en UI**: Filtrado y transformaciones podrían externalizarse
- **Estado global DataFrame**: Podría gestionarse vía patrón Repository
- **Threading manual**: Podría migrar a async/await o pool managed

## 10. Pruebas recomendadas (test design)

### Happy path mínimos
```python
def test_app_initialization():
    # Verificar inicialización correcta de 4 pestañas y tema
    
def test_file_selection_and_processing():
    # Mock FileDialog, verificar threading y actualización log
    
def test_data_loading_and_display():
    # Mock database_manager, verificar carga TreeView
    
def test_dashboard_filtering():
    # Verificar regeneración gráficos con diferentes filtros
```

### Bordes
```python
def test_processing_with_corrupted_pdf():
    # PDF corrupto, verificar manejo de error y continuación
    
def test_database_locked_during_load():
    # SQLite bloqueado, verificar retry o error graceful
    
def test_large_dataset_performance():
    # 1000+ registros, verificar tiempo de carga aceptable
```

### Doubles y fixtures
- **Mock `procesador_ihq_biomarcadores`**: Para aislar procesamiento de UI
- **Mock `database_manager`**: Para controlar datos de prueba
- **Fixture PDFs**: Archivos de prueba con diferentes características
- **Mock Matplotlib**: Para acelerar pruebas de dashboard sin renderizado

## 11. Riesgos y mitigaciones

| Riesgo | Impacto | Probabilidad | Mitigación implementada |
|--------|---------|--------------|------------------------|
| **Bloqueo UI durante procesamiento** | Alto | Muy bajo | Threading obligatorio para operaciones largas |
| **Memoria insuficiente con datasets grandes** | Medio | Medio | DataFrame chunking implícito, lazy loading TreeView |
| **Corrupción base datos durante escritura** | Crítico | Bajo | Transacciones SQLite, rollback automático |
| **Fallo Selenium por cambios portal** | Medio | Alto | Try-catch con logging detallado, graceful fallback |
| **Renderizado lento gráficos complejos** | Bajo | Alto | Filtros por defecto limitan datasets, toggle de gráficos |
| **Pérdida de credenciales portal** | Bajo | Medio | Re-entrada manual, no persistencia por seguridad |

## 12. Evidencias

### Referencias exactas
- **Inicialización App**: `ui.py:110-140` - Constructor con configuración CustomTkinter y tema
- **Threading procesamiento**: `ui.py:420-450` - Función `process_files_thread()` completa
- **Dashboard analytics**: `ui.py:800-900` - Método `create_dashboard_tab()` con Matplotlib
- **TreeView maestro**: `ui.py:600-650` - Configuración tabla con datos y búsqueda
- **Gestión de estado**: `ui.py:180` - Variable `master_df` como fuente única de verdad
- **Automatización web**: `ui.py:1150-1200` - Integración con `huv_web_automation`

### Limitaciones del análisis
- **Código extenso**: 1299 líneas requieren análisis por secciones específicas
- **Widgets complejos**: Algunos CustomTkinter widgets tienen comportamiento no documentado
- **Interacción Matplotlib-Tkinter**: Embedding puede tener limitaciones de rendimiento no evidentes